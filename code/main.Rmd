---
title: "Modelagem geoestatística do carbono orgânico do solo"
author: "Moura-Bueno"
date: "12 de dezembro de 2017"
output: html_document
  #bookdown::word_document2:
      #reference_docx: ../docs/template.docx
      #bibliography: biblio.bib
csl: abnt.csl
lang: pt
editor_options: 
  chunk_output_type: inline
---

```{r, eval=FALSE}
rmarkdown::render('main.Rmd', encoding = 'UTF-8', output_dir = "../docs")
```

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE, include=FALSE}
# Carregar pacotes 
library(magrittr)
library(dplyr)
library(glue)
library(lattice)
library(sp)
library(raster)
library(caret)
library(georob)
library(gstat)
```

```{r}
# Sistemas de referência de coordenadas (Fonte: http://spatialreference.org/ref/epsg/)
wgs84utm21s <- sp::CRS('+proj=utm +zone=21 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs')

# Definir rampa de cores
col_soil_var1 <- topo.colors(100)
```

# ATIVIDADE 

# Realizar a modelagem geoestatística do carbono orgânico do solo

# Caracterização da área de estudo

Os dados utilizados para realizar essa atividade foram obtigos em uma área de ~ 940 ha no município de Giruá. As amostras de solo foram coletadas em 261 pontos na camada de 0-5 cm de forma intencional. O suporte amostral foi em BLOCO (área de ~ 36 m^2^), no entanto, para reliazar a atividade foi assumido que o suporte amostral foi de PONTO. 
Nessa atividade foi realizada a predição da variável de solo "Carbono Orgânico do Solo" utilizando o Modelo Linar Misto de Variação Especia. No final da atividade foi realizada uma simulação sequencial gaussiana condicional.

```{r}
# Carregar arquivo vetorial referente ao uso da terra de Giruá
cobertura <- 
 raster::shapefile('../data/uso-da-terra.shp') %>%
 sp::spTransform(wgs84utm21s)
cobertura$uso <- as.factor(cobertura$uso)
```

```{r}
sp::spplot(
  cobertura, scales = list(draw = TRUE), col.regions = terrain.colors(nlevels(cobertura$uso)),
  main = "Mapa de uso da terra")
```

```{r}
# Carregar planilha contento variáveis dos 261 pontos de amostragem, camada 0 - 5 cm
pontos <- read.csv('../data/pontos-261-1.csv', sep = ";", dec = ".", header = TRUE)
sp::coordinates(pontos) <- c('x', 'y')
sp::proj4string(pontos) <- wgs84utm21s
pontos@data
```

```{r}
# estatística descritiva dos pontos de carbono orgânico do solo (soc)
op <- par(mfrow = c(1, 2))
summary(pontos)
hist(pontos$soc)
boxplot(pontos$soc)
par(op)
```

```{r}
bubble(pontos, "soc")
```


```{r}
# Gerar mapa de uso da terra com os 261 pontos de amostragem
sp::spplot(
  cobertura, scales = list(draw = TRUE), 
  xlim = extendrange(c(pontos@bbox[1, ], cobertura@bbox[1, ])),
  ylim = extendrange(c(pontos@bbox[2, ], cobertura@bbox[2, ])),
  col.regions = terrain.colors(nlevels(cobertura$uso)),
  main = "Localização das 261 observações") +
  lattice::xyplot(y ~ x, data = as.data.frame(pontos@coords), pch = 20, col = 'black') %>%
  latticeExtra::as.layer()
```

```{r}
# carregar covariáveis preditoras obtidas no TOPODATA (30 m) e mapa de uso da terra
# ASR: Há um erro mais abaixo no cluster que indica a inexitência do objeto 'elev'. Parece que ele está nomeado
# como 'ELEV'.
# JB: aqui não aparece esse erro com o arquivo 'elev'.
# ASR: O erro aparece abaixo, no cluster.
# ASR: Ao carregar os dados vejo que já estão no wgs84utm21s. Eles foram alterados? 
elev <- raster::raster('../data/ELEV.tif')
names(elev) <- "elev"
# sp::proj4string(elev) <- wgs84utm21s
decli <- raster::raster('../data/decli.tif')
# sp::proj4string(decli) <- wgs84utm21s
vertnum <- raster::raster('../data/vertnum.tif')
# sp::proj4string(vertnum) <- wgs84utm21s
uso <- raster::raster('../data/uso.tif')
# sp::proj4string(uso) <- wgs84utm21s
```

```{r}
# extrair valores da covariávies para os 261 pontos
pontos$elev <- raster::extract(elev, pontos)
pontos$decli <- raster::extract(decli, pontos)
pontos$vertnum <- raster::extract(vertnum, pontos)
pontos$uso <- raster::extract(uso, pontos) %>% as.factor()
pontos@data
```

#  Modelo de predição de carbono orgânico por Randon Forest 

```{r}
# criar modelo de predição de SOC por Randon Forest
soc_rf <- caret::train(
  soc ~ elev + decli + vertnum + uso, data = pontos@data, method = 'rf', importance = TRUE)
varImp(soc_rf)
```

```{r, fig.asp=1}
# gerar gráfico para viasualização dos resíduos da predição
op <- par(mfrow = c(2, 2))
pontos@data$socpred <- soc_rf$finalModel$predicted
fig <- lm(soc ~ socpred, data= pontos) 
plot(fig, which = 1:4)
par(op)
```

```{r}
# ASR: Qualidade do ajuste. A correlação é bastante baixa.
summary(fig)
```

```{r}
# Fazer a predição espacial para toda área a partir do modelo gerado - soc_rf
beginCluster()
prediction <-
  clusterR(brick(elev, decli, vertnum, uso), raster::predict, args = list(model = soc_rf, type = 'raw', inde = 1))
endCluster()
```

```{r}
plot(prediction, main = "Mapa de carbono orgânico - componente determinístico")
```


```{r}
# Criar o objeto "socprediction" na arquivo "pontos"
# ASR: Os dados a serem usados são do modelo calibrado acima, já armazenados na coluna 'socpred', e 
#     considerados como os valores ajustados pelo modelo.
# pontos$socprediction <- raster::extract(prediction, pontos)
```

# Construir o Modelo Linear Misto de Variação Espacial

## Variograma amostral

```{r}
# resíduos da floresta aleatória
pontos$res_rf <- pontos$socpred - pontos$soc
bubble(pontos, "res_rf", main = "Resíduos da floresta aleatória")
```


O variograma amostral foi computado através da função georob::sample.variogram. O estimador para semivariãncia foi Metheron (método dos momentos). Para a obtenção dos parâmetros utilizei um corte de 50% da distância máxima entre os pontos, armazenada no objeto distmax, excluindo os pares de longo alcance.

```{r}
# Calcular a distância em entre pontos e gerar o varigrama amostral
distmax <- dist(pontos@coords) %>% 
 max() / 3 # ASR: Sugiro usar 3, o mesmo valor usado pelo gstat. 2 é o limite e tu tens muitos pontos próximo.

# O valor predito de SOC pelo  modelo "soc_rf" foi o efeito fixo do Modelo Linear Misto de Variação Espacial 

# ASR: dá para abusar aqui, pois 30 pares por lag já é mais do que suficiente. Ademais, mostra que não sobra 
#     estrutura espacial. Bom mostrar acima as distâncias entre os pontos vizinhos. 
limites <- seq(0, distmax, length.out = 20) 
# ASR: não se usa o socprediction, mas sim o socpred
vario <- georob::sample.variogram(soc ~ socpred, data = pontos,
    locations = ~ x + y, lag.dist.def = limites, estimador = 'matheron') %>% 
  plot(ylab = 'Semivariância', xlab = 'Distância de separação', annotate.npairs = T)
```

```{r}
# ASR: O modelo ajustado é o esférico. Pela forma do variograma, não faz sentido ajustar esse modelo com os 
#     parâmetros informados. Se já tem conhecimento do efeito pepita, informe-o aqui.
# Ajuste do variograma amostral a um modelo exponencial 
# Foi utilizdo O método dos quadrados mínimos não-lineares ponderados, sendo a ponderação definida conforme o método de "Cressie"
# As estimativas dos parâmetros do modelo foi realizada pelo método "BFGS"

vario_fit <-
  georob::fit.variogram.model(vario, variogram.model = 'RMspheric', param = c(variance = 0.7, nugget = 0.5, scale = 1000),  weighting.method = "cressie", method = 'BFGS')
summary(vario_fit)
```

```{r}
plot(vario, type = 'b', ylab = 'Semivariância', xlab = 'Distância de separação (m)')
lines(vario_fit, col = 'blue', lty = 'dashed')
```

```{r, warning=FALSE}
# ASR: Veja que o modleo é o esférico. Sugiro usar o exponencial ou Mattern.
# Ajuste do variograma com a sepração da variância estrutural (snugget) e não estrutural (nugget)
# foi fixado o snugget em 0.0025, sendo esse valor referente ao erro de análise de laboratório

nugget <- 0.0025 # Tem que explicar de onde isso vem, mostrar o cálculo.

# ASR: socpred
vario_fit_error <- georob::georob(
   soc ~ socpred, pontos, locations = ~ x + y, variogram.model = 'RMspheric', 
 param = c(variance = vario_fit$variogram.object[[1]]$param[['variance']], 
           nugget = nugget,
           snugget = vario_fit$variogram.object[[1]]$param[['nugget']] - nugget,
           scale = vario_fit$variogram.object[[1]]$param[['scale']]),
 fit.param = georob::default.fit.param(nugget = FALSE, snugget = FALSE),
 tuning.psi = 1000, control = georob::control.georob(initial.fixef = 'lm'))
summary(vario_fit_error)
```

```{r}
plot(vario, ylab = 'Semivariância', xlab = 'Distância de separação (m)')
lines(vario_fit_error, col = "red", lty = 'dashed')
```

```{r}
# criar grid para realizar a predição pelo Modelo Linear Misto de Variação Espacial
grid <- sp::spsample(cobertura, 10000, type = 'regular')
# plot(grid@coords, asp=1)
colnames(grid@coords) <- colnames(pontos@coords)
```

```{r}
# ASR: socpred ao invés de socprediction
# Inserir o valor predido "prediction" no grid
grid$socpred <- raster::extract(prediction, grid)
```


```{r}
grid <- 
 sp::SpatialPointsDataFrame(
   coords = grid@coords, 
   data = data.frame(grid),
   proj4string = grid@proj4string)
colnames(grid@coords) <- colnames(pontos@coords)
```

```{r}
pred_ponto <- raster::predict(vario_fit_error, newdata = grid, na.action = na.omit, control = georob::control.predict.georob(extended.output = F))
sp::gridded(pred_ponto) <- TRUE
```

```{r}
plot(pred_ponto, 
     main = "Mapa de carbono orgânico gerado pelo modelo linear misto de variação espacial")
```


```{r, fig.asp=1}
validacao <- georob::cv(vario_fit_error)
summary(validacao)
1 - sum((validacao$pred$data - validacao$pred$pred)^2) / sum((validacao$pred$data - mean(validacao$pred$data))^2)
plot(validacao)
```

# Simulação sequencial gaussiana condicional

```{r}
# Simulação 
m_exp <- gstat::vgm(psill = 32.87, model = 'Exp', range = 436800, nugget = 0.57)
cond_sim <- gstat::krige(soc ~ socprediction, pontos, grid, model = m_exp, nmax = 15, nsim = 8)
```

```{r}
gridded(cond_sim) <- TRUE
spplot(cond_sim)
```

```{r}
cond_sim_prop <- 
  calc(stack(cond_sim), function (x) x > 5) %>% 
  calc(sum) %>% 
  calc(function (x) x / 8)
plot(cond_sim_prop, asp = 1)
```

